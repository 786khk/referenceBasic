```
int hashCodeRange(int from, int to) {
        final Object[] es = elementData;
        if (to > es.length) {
            throw new ConcurrentModificationException();
        }
        int hashCode = 1;
        for (int i = from; i < to; i++) {
            Object e = es[i];
            hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());
        }
        return hashCode;
    }
 // ArrayList.class 의 hashcode() 메소드에서 31은 무엇을 말하는건지 모르겠습니다.
```
적당한 사이즈에서 의미있는값을 찾는다.
약수가 많다는것은 겹치는 경우가 많다는것이기때문에 더 복잡해짐
제일 작은 수 ??

일단 많이 쓰이는 수는 소수이다.
적당한 사이즈며, 소수이며, 비트로 완벽하게 계싼이 되고,.. 그게 31
충돌이 안나려면 골고루 분배가되어야 함


```
```

메모리에 올라가있는객체를 다른 것으로 전송할 때 똑같은형태로 전송해서 전달받은데서 이객체정보를사용할 수 있다 같은언어일경우는 같은 직렬화를 할 수 ㅣㅇㅆ는데
자료형에 구애받지않는 데이터 전송기법이 필요했다 그래서 json이 채택됐음
레지스터 올릴떄 값을 해시맵으로저장하는애들을대상으로 진행이된다
시리얼라이징이없으면 패스
JVM과는 상관없음
DB에 쓸때도 직렬화를사용함 모델을 만들 수 있으니까



```
TreeSet 클래스에서 추가 삭제를 할경우 트리의 일부를 재구성 한다고 책에 나와있는데 특정 노드 삭제 이후에 어떤 식으로 tree구조가 만들어지는지 방법이 나와있지않아 순서가 이해가 되지 않습니다
```
level 1에서 하위  

차수가 거듭할수록 2 씩증가함다.
2의 32승까지 즉 42억번의 연산이 된다.
이 때 왜 일까? 
3이고 5는씩은안될까?
비교횟수를 줄이기 위해 대부분 2에서 끝난다.
비교를 하면서 솎아지면 비교할 숭 ㅣㅆ는 횟수가 줄어서 빨라진다.

tree의 단점

1,2,3,4,5 가 대입될 때 한쪽으로 치우쳐진 트리가 된다. 순차적으로 증가하는값이들어오면 트리가 아닌 배열, 성능의 문제가 중점이다.

linkedList는 노드만 바꿔서 삭제하면되니까 좀더빠름 , 트리를 만드는 목적은

속도와 메모리 둘중하나를포기하자

트리를만드는건 검색을 빠르게하기위해서다.
어떻게하면 더 빨리 할 수 있을까?라는 생삿에 알거리듬을 만듬

레드블랙트리 실제구현도 해보기




```
책에서 Vector나 Hashtable 대신 ArrayList와 HashMap을 사용하라 하는데 Vecotr나 Hashtable은 프레임웍의 명명법에 따르지않아서 인지 다른 큰 차이점들이 있는지 궁금합니다.

Enumeration을 대신 Inerator를 사용하자는 내용이 있는데 Enumeration을 사용하지 않는 이유에 대해 궁금합니다.
```

- 구형이라 안씀
- 언어가 발생하면 의존성을 주리는것을 중점으로 한다.
- 위의 기능에 맞게 Iterator가 구현되어있다.



```
HashSet은 순서가 정해져 있지 않는데. 굳이 정렬을 이용하고자 하는 경우가
중복허용되지 않는 기준으로 정렬하기 위해서 사용하는걸까요?

정렬하는 방법으로는

1. List로 변환하고 정렬
2. TreeSet으로 변한하여 정렬
3. Stram 이용하여 정렬

이 있던데, 가장 많이 사용하는 정렬이 어떤건지 궁금합니다.
```

map은 구조가 배열이고 순서대로 넣는게 아니라 알고리즘에 의해 계산돼서 들어간다.
깊이우선탐색으로 트리셋을 검색한다.
노드를 따라 가면되기떄문에 이 외는 다른 이야기.


stack queue 는 내가 어떻게 쓸지 알고리즘을 정하면서


자료구조가 한정적인 이유는 사용자가 쓰는방법에따라 많으면복잡해지기떄문에 한정적이다.

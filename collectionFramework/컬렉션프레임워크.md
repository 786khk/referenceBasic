# 컬렉션 프레임워크

- 데이터 군을 저장하는 클래스들을 표준화한 설계
- 다수의 데이터, 즉 데이터그룹을 프레임웍은 표준화된 프로그래밍 방식을 의미
- 컬렉션프레임워크의 도입으로모든 컬렉션 클래스를 표준화된 방식으로 다룰 수 잇도록 체계화됨(JDK1.2 이후 부터)
- 인터페이스와 다형성을 이용한 객체지향 설계를 통해 쉽고 재사용성 높은 코드를 작성할 수 있다.

## 핵심 인터페이스
- List Set,Map으로 크게 분류할 수 있다.
- 컬렉션프로엠워크는 위 언급한 3가지의 형태로 인터페이스를 정의했다.
- Map을 제외한 Set과 List는 공통된 기능을 새로운 인터피세으 Collection을 추가로 정의했다.

![image](https://user-images.githubusercontent.com/78067072/223324038-9e8736c6-670a-4dfd-9e24-c4a177095675.png)

실제 Collection에 들어가보면 Collection은 인터페이스며 참고해야하는 부분을 보면 컬렉션 프레임웍 클래스들이 나와있다.

|인터페이스 |특징| 구현 클래스 |
|---|---|---|
|List| 순서가 있는 데이터의 집합. 데이터의 중복허용|ArrayList, LinkedList, Stack, Vector, ...|
|Set |순서를 유지하지 않는 데이터의 집합. 데이터의 중복 허용 안함| HashSet, TreeSet|
|Map | key,valu의 쌍으로 이루어진 데이터 집합. 순서 유지는 안된다. 키는 중복이 될 수 없으며 값은 중복 허용| HashMap, TreeMap, Hashtable, Properties, ...|

- 컬렉션 프레임웍의 모든 프레임워크들은 List, Set, Map중 하나를 구현하며 구현한 인터페이스 이름이 포함돼 있음
- Vector, Properties,Stack, Hashtable과 같은 클래스는 컬렉션 프레임워크가 만들어지기전부터 존재했기때문에 컬렉션프레임웍 인터페이스의 명명법을 따르지 않는다.
- 실제로 기존 컬렉션 클래스들은 호환을 위해 남겨놨지만 지양한다. 

### Collection 인터페이스 

- Collection인터페이스는 컬렉션을 다루는데 가장 기본적인 메서드를 정의한다. 
- List와 Set의 조상인 Collection인터페이스에는 다음과 같은 메서드들이 정의돼 있다.
- java API문서를 보면 메서드 매개변수들이 object가 아닌  E라고
|메서드|설명|
|---|---|
|boolean add(Object o ) / boolean addAll(Collection  c) | 지정된 객체(o)또는 Collection 객체들을 Collection에 추가한다.|
|void clear() |  Collection의 모든 객체들을 삭제한다.|
|boolean contains(Object o )/ boolean containsAll(Collection o ) | 지정된 객체(o)또는 Collection 객체들을 Collection에 추가한다.|
|boolean equals(Object o1, Object o2) | 동일한 Collection인지 확인한다.|
|int hashCode() | Collection의 Hashcode 리턴|
|boolean isEmpty() |  Collection이 지어있는지 확인|
|Iterator iterator()|Collection의 Iterator를 억어 반환|
|boolean remove(Obejct o) | 지정된 객체 삭제|
|boolean removeAll(Collection c) |지정괸 Collection에 포함된 객체들을 삭제.|
|boolean retainAll(Collection c) | 지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection에서 삭제. 이 작업으로 Collection에 변화가 있으면 true, 그렇지 않으면 false|
|int size() | 동일한 Collection에 저장된 객체의 개수를 반환|
|boolean toArray() | Collection에 저장된 객체를 객체배열(Object[])로 반환|
|boolean toArray(Object[] a) | 지정죈 배열에 Collection의 객체를 저장해 반환|


### List 인터페이스

- 중복을 허용하며 저장순서가 유지된다.

|메서드|설명|
|---|---|
|void add(int index, Object element)| 지정된 위치(INDEX)에 객체(element) 또는 컬렉션에포함된 객체 추가|
|Object get(int index)| 지정된 위치(INDEX)에 객체(element)를 반환|
|int indexOf(Object element)| 지정된 객체의 위치(INDEX)를 반환|
|int lastIndexOf(Object element)| 지정된 객체의 위치(Index)를 반환, 진행방향이 역순|
|ListIterator listIterator(int index) / ListIterator listIterator()| List객체에 접근할 수 있는 Iterator 반환|
|Obejct remove(int index)| 지정된 위치(INDEX)에 객체를 삭제하고 삭제된 객체를 반환|
|Object set(int index, Object element)| 지정된 위치(index)에 객체(element) 저장|
|void sort(Comparator)| 지정된 비교자(comparator)로 List 정렬|
|List subList(int fromIndex, int toIndex)| 지정된 범위(fromIndex, toIndex)에 있는 객체를 반환|

- 위의 표는 Collection인터페이스로부터 상속받은 기능은 제외했다.
### Set 인터페이스

- 중복을 허용하지 않고 저장순서가 유지된다.

### Map 인터페이스

- key,value 쌍으로 묶어 저장한다. key는 중복될 수 없지만 값은 중복될 수 있다.
- 기존에 저장된 key와 값을 저장하면 새롭게 덮어씌어진다.
- 어떤 두 값을 연결한다는 뜻에서 Map이라고 붙여졌다.

|메서드| 설명|
|---|---|
|void clear()| Map의 모든 객체를 삭제|
|void clear()| 지정된 key객체와 일치하는 Map의 key객체가 있는지 확인 |
|boolean containsValue(Object value)| 지정된 value객체와 일치하는 Map의 vlaue객체가 있는지 확인|
|Set entrySet()| Map에 저장된 key-value쌍을 Map.Entity타입의 객체로 지정한 Set으로 반환|
|boolean equals(Object o)| 동일한 Map인지 비교|
|Object get(Object key)| 지전된 key에 대한 데이터를 반환|
|int hashCode()| 해시코드 반환|
|boolean isEmpty()| Map이 비어있는지 확인한다|
|*Set keySet()*| Map에 저장된 모든 key 객체를 반환|
|Object put()| Map에 value객체를 key객체에 연결(mapping)해 저장|
|void putAll(Map t)| 지정된 Map의 모든 key-value쌍을 추가 |
|Object remove(Object key)| 지정한 key와 일치하는 key-value를 삭제한다.|
|int size()| Mapdp 저장된 key-value쌍으 갯수를 반환|
|*Collection values()*| Map에 저장된 모든 value객체 반환|

- Map 인터페이스는 값은 중복을 허용하지만 키는 중복을 허용하지 않기때문에 keySet()은 반환타입이 Set이다.


### Map.Entry인터페이스

- Map인터페이스 내부 인터페이스. 내부클래스같이 인터페이스 안에 내부 인터페이스를 가질 수 있다.
- Map은 key-value쌍을 다루기 위해 내부적으로 Entry인터페이스를 정의해 놓음(객체지향적 설계유도). Map을 구현하는 클래스에서 Map.Entry도 구현해야 한다.
-


# java.lang

- 자바 개발에 필요한 기본 클래스 포함됨
- import 문 없이도 사용할 수 있다.


### Object

- 모든 클래스들의 최고 조상
- 맴버 변수는 없고  모든인스턴스가 가져야 할 기본 11개의 메서드만 가진다. 


|메서드| 설명 |
|---|---|
|protected Object clone() | 객체의 복사본 반환(return)|
|public boolean equals(Obejct obj)| 객체 자신과 obj가 같은지 반환 |
|protected void finalize()| 객체가 소멸될때까지 컬렉터에 의해 자동호출. 이 때 수행되어야 하는 코드가 있을 때 오버라이딩(거의 사용 안함)|
|public Class getClass()|객체 자신의 클래스 정보를 담고있는 Class인스턴스 반환|
|public int hashCode()|객체 자신의 해시코드 반환|
|public String toString() | 객체 자신의 정보를 문자로 반환|
|public void notifyAll()| 객체 자신을 사용하려는 모든 쓰레드를 깨운다.|
|public void notify()| 객체 자신을 사용하려는 쓰레드를 하나만 깨운다.|
|public void wait(),public void wait(long timeout),public void wait(long timeout, int nanos)| 다른 쓰레드가 notify()나 notifyAll()을 호출할 때 까지 현재쓰레드를 무한 또는 정ㅈ지정된 시간(timeout, nanos)동안 기다리게 한다. (timeout은 천분의1초, nanos는 10⁹의 1초)|


##### equals(Object obj)
- 매개변수로 객체의 참조변수를 받아 비교해 그 결과 boolean으로 리턴

```java
    // 실제 Object속에 있는 equals메서드
    public boolean equals(Object obj){
        return (this===obj);
    }

```
- 객체를 비교할 때는 객체의 주소값을 비교함
```java

    Value v1 = new Value(10);
    Value v2 = new Value(10);
    
    if(v1.equals(v2))
        System.out.println("v1==v2"); 
    else 
        System.out.println("v1!=v2");   

//결과 : v1!=v2
```

해당 예제는 [utilClass/EqualsEx1](https://github.com/786khk/referenceBasic/blob/main/utilClass/EqualsEx1.java) 에서 확인 가능


- String클래스도 Object class 오버라이딩하기때문에 인스턴스가 갖는 문자열 값을 비교한다.
```java

    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        return (anObject instanceof String aString)
                && (!COMPACT_STRINGS || this.coder == aString.coder)
                && StringLatin1.equals(value, aString.value);
    }

```
- String 뿐만 아니라 File, Date. warpper믈래스 또한equals를 사용해 내용을 비교하돍 되어있음 
- StringBuffer는 equals가 오버라이딩 안됨

#### hashCoede()

- 해싱 기법에 사용되는 Hash Function(해시 함수)를 구현한 것
- 해싱은 데이터관리기법으로 다량의데이터를 저장하고 검색한다.
- 찾고자 하는 값을 입력하면 그 값이 저장된 위치를 알려주는 해시코드(hashCode) 반환
- 일반적으로 같은 두 객체가 존재하는 것이 가능하지만 Oject 클래스의 해시값은 주소값으로 해시코드를 반환
- 32bit JVM은 두 객체가 값은 해시코드를 가질 수 없음
- 64bit JVM은 8byte주소값으로 해시코드를 만들어 중복될 수 있음
- 위의 설명에서 인스턴스변수로 객체의 같음을 판단할 때 equals뿐 아니라 hashCode도 같이 비교해야하기때문에  메서드도 적절히 오버라이딩한다.

```java
        String s1 = new String("김현경");
        String s2 = new String("김현경");

        System.out.println(s1.equals(s2));
        System.out.println(s1.hashCode());
        System.out.println(s2.hashCode());
        
        System.out.println(System.identityHashCode(s1));
        System.out.println(System.identityHashCode(s2));

        System.identityHashCode() // 주소값으로 항상 다른 해시코드를 만들기때문에 실행할때마다 값이 다름
        
````

#### ✔`hashCode()`와 `System.identityHashCode()`의 차이 

 - 똑같이 객체의 주소값으로 해시코드를 만들지만 생성되는 기능의 차이가 있음 
 - `hashCode()`는 객체 내용에 대한 해시코드를 생성함. Object 의 hashCode를 `오버라이딩`하기때문에 같은 hashCode들이 있을 수 있음
 - `System.identityHashCode()` 은 객체의 고유한 해시코드 리턴한다, null에 대한 리턴값은 0
 - 위 예제처럼 내용이 같은 String객체일 경우 서로 주소값은 다르지만 Object.hashCode()를 모버라이딩하기때문에 같은 해시코드를 가질 수 있지만 System.identityHashCode()는 오버라이딩하지 않고 객체 주소값으로만 해시코드를 생성한다.

### toString()

```java

   public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }

```
- 인스턴스 변수에 저장된 값들을 문자열로 제공한다.
- 클래스 이름에 16진수의 해시코드 리턴

```java

class Card{
    String king;
    int num;
    public Card(String king,int num){
        this.num = num;
        this.king = king;
    }
    public Card(){
        this("SPADE",1);
    }
}
public class ToString1 {
    public static void main(String[] args) {
        Card c1 = new Card();        
        Card c2 = new Card();        
        System.out.println(c1);//utilClass.Card@372f7a8d
        System.out.println(c2);//utilClass.Card@2f92e0f4
        System.out.println(c1.toString());//utilClass.Card@372f7a8d
        System.out.println(c2.toString());//utilClass.Card@2f92e0f4
        /**
            Object.toString()을 오버라이딩 하지 않았기때문에 클래스 이름.@해시코드값으로 출력
         * 
         */
    }
    
}

```

- 같은 타입의 클래스라도 주소는 다르다는것을 알 수 있음




```java

    public String toString(){
        return "kind : "+kind + ", number: "+ num;
    } 
    

    Cards c1 = new Cards();        
    Cards c2 = new Cards("HEART",10);      
        
    System.out.println(c1.toString());//kind : SPADE, number: 1
    System.out.println(c2.toString());// kind : HEART, number: 10


```
- 위 메서드 추가 후 카드정보가 출력된다.
- toString()메서드를 public으로 설정했다. Object.toString()이 public이기때문에 부모의 접근제어자와 같거나 더 넓어야 하기때문에 public 으로 함


### clone()

![image](https://user-images.githubusercontent.com/78067072/222942822-6f9358e7-3460-4971-a523-d7e3bb06d018.png)

위 사진은 Cloneable클래스의 전문..
대략 객체 clone시 해당클래스를 구현해야한다는 말이다.



```java

    @IntrinsicCandidate
    protected native Object clone() throws CloneNotSupportedException;

```
- 자신을 복제해 새로운 인스턴스를 만든다.
- 원래의 인스턴스 보존하고 새로 생성해 작업이전의 값이 보존되기때문에 작업에 실패해 원래의 상태로 돌려놓거나변경 전 값을 참고하는데도움이 됨
- Object.clone()은 단순히 인스턴수 변수가 복제되는지라 참조타입의 인스턴스 변수가 있는 클래스는 완전한 복제가 되지않는다.
- 같은 주소값을 참조하기 때문에 원래의 데이터에 영향을 미치게된다.
- 이럴경우 아래와 같이 colne메서드를 오버라이딩해야 한다. 

```java

class Point implements Cloneable{
    int x,y;
    public Point(int x, int y){
        this.x = x;
        this.y = y;
    }

    public String toString(){
        return "x: "+ x+ ", y: "+y;
    }
    public Object clone(){
        Object obj = null;
        
        try {
            obj = super.clone(); //반드시 예외처리!
        } catch (CloneNotSupportedException e) {}

        return obj;

    }
}

```

- clone() 메서드를 오버라이딩 할 때 반드시 `Clonable인터페이스를 구현`한다.(데이터 보호를 위해, 이 인터페이스를 구현한다는 것은 개발자가 복제를 허용한다는 의미)
- 꼭 반드시 `조상(Object) clone메서드 사용시 try~ cath 내 호출`을 한다.
- Object.clone()은 `protected로 되어있지만 접근제어자는 반드시 public으로 구현`해야 다른 클래스에서 호출할 수 있다. 


### 공변 반환타입

- JDK1.5부터 추가됨
- 오버라이딩시 조상메서드 반환타입을 자손 클래스로 변경을 허용한다.


```java



```

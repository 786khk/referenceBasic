# 객체지향 언어

### 객체지향 언어의 주요 특징

- 코드의 `재사용성`이 높다.
  - 새 코드 작성시 가존 코드를이용해 쉽게 작성
- `코드 관리 용이`
  - 코드간 관계를이용해 적은 노력으로 쉽게 변경
- 신뢰성 높은 프로그래밍 가능
  - 제어자와 메서드로 데이터를 보호, 올바른 값 유지하며 코드중복제거로 코드의 불일치로 인한 오작동 방지

## 클래스와 객체

#### 클래스와 객체의 정의와 용도

- 클래스의 정의 : 객체를 정의해 놓은 것
- 클래스의 용도 : 객체를 생성하는데 사용
- 객체의 정의 : 실존, 사물 또는 개념
- 객체의 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름

- 유형객체 : 책상, 의자, 자동차 등
- 무형 객체 : 수학공식, 프로그렘 에러같은 논리나 개념

#### 객체와 인스턴스

- 인스턴스화 : 클래스로 부터 객체를 만드는 과정
- 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고한다.

- 객체는 속성과 기능의 집합
- 객체가 가지고 있는 속성과 기능을 그 객체의 맴버라고한다.

### 인스턴스의 생성과 사용

- 클래스로 부터 인스턴스 생성방법중 일반적인 방법

```java

Tv t;
t = new Tv();// 


```

```java


public class TvTest {
    public static void main() {
        Tv t;
        t = new Tv();// 인스턴스 생성
        t.channel=7;// 인스턴스의 멤버변수 사용
        t.channelDown();
        System.out.printf("현재 채널은 %d 입니다.",t.channel);
    }
}
class Tv{
    String color;
    boolean power;
    int channel;

    void power() {power =!power;}
    void channelUp() {++channel;}
    void channelDown() {--channel;}

}


```

- 인스턴스틑 참조변수를 통해 다룰 수 있음
- 참조변수 타입은 이스턴스 타입과 일치해야함
- 예제에서 t1과 t2를 생성한 후 인스턴스 t1의 맴버변수인 channel의 값을 변경하는 부분을 보아 같은 형태의 객체여도 서로 다른 값을 유지할 수 있으며 메서드 내용은 모든 인스턴스에 대해 동일하다.

## 객체 배열 - 다형성
- 객체 배열 안에 객체가 저장되는 것은 아니고 객체의 주소 저장
- 객체 배열은 참조변수들을 하나로 묶은 참조변수 배열

## 클래스의 또 다른 정의
- 클래스 ? 객체를 생성하기 위한 틀
- 클래스 속성과 기능으로 정의
### 데이터와 함수의 결함 
- 변수 : 하나의 데이터를 저장하는 공간
- 배열 : 같은 종류의 데이터를 하나의 집합으로 저장할 수 있는 공간
- 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
- 클래스 : 데이터와 함수의 결합(구조체 + 함수)
- 함수는 주로 데이터를 가지고 작업을 하기떄문에 많은 경우 데이터와 함수의 관계가 깊어 자바의 클래스 내 관계가 있는함수, 변수들이 정의되도록함
  - 관계가 깊다는의미?
    - 간단하게 말하자면 C언어에서 문자열은 문자의 배열로 지칭하지만 java에서 문자열은 하나의 객체로 String으로 정의함(이 사항은java 9까지의 사항)
    - java 9 이후 String 내부 클래스는 더이상 Char[] 가 아닌 byte[]를 사용해 메모리 사용을 줄이고 성능을 향상시킴
```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence,
               Constable, ConstantDesc {

   @Stable
    private final byte[] value;
    // 문자열 기능을 사용할 때 문자열을 작업대상으로 필요로 하기때문에 문자열과 깊은 관계에있음

    ...
}
```
### 클래스 - 사용자 정의타입
- 자료형 외 개발자가 서로 관련된 변수들을 묶어 하나의 타입으로 새로 지정하는 타입
```java

int hour1, hour2, hour3;
int minute1, minute2, minute3;
float second1, second2, second3;

// 위와 같이 3개의 시간으 다룰경우세개의 변수를 선언하지만 다루는 객체가 많을수록 변수를 추가해야함

int[] hour = new int[3];
int[] minute = new int[3];
float[] second = new float[3];

// 변수를 매번 선언하는 불편함은 없지만 시분초가 분리돼있어 잘못된 시간이 반환될 수 있음

public class Time {
   private int  hour;
   private int  minute;
   private float  second;
}
// 사용자 정의 클래스로 하나로 묶어 시간관리
```

## 변수와 메서드
### 선언 위치에 따른 변수의 종류
- 클래스 변수, 인스턴스 변수, 지역변수 세종류
- 이 기준은 변수 선언위치에따라 결정
- 클래스 변수는 앞에 static 키워드가 있음


|변수 종류| 선언 위치 | 생성시기|
|---|---|---|
|클래스 변수|클래스 영역|클래스가 메모리에 올라갈 때|
|인스턴스 변수|클래스 영역|인스턴스가 생성될 때|
|지역 변수|클래스 영역 외 영역|번수 선언문이 수행되었을 때|
#### 인스턴스 변수
- 독립적 저장공간을 가지는 인스턴스의 특성으로 인스턴스마다 고유의 값을가져야할 때사용
#### 클래스변수
- 인스턴스 변수 선언시 앞에 static 키워드 사용
- 모든 인스턴스가 공통된 저장공간을 공유해 인스턴스들이 공통적인 값을 유지할때사용
- `클래스 이름.클래스변수`로 사용
- 클래스가 메모리에 로딩될때부터 프로그램 종료시까지 유지, 전역변수의 성격

#### 지역변수
- 메서드 내 사용되는 변수
- 메서드 종료시 소멸 
- {}내에서 유효

### 메서드
- 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
- 수학의 함수와 유사

#### 메서드를 사용하는 이유
##### 높은 재 사용성
- JAVA API에서 제공하는 메서드들을 사용하면서 경험한것처럼 한 번 만들어 놓은메세드를 몇번이고 호출할 수 있다
##### 중복 코드의 제거
- 반복되는 문장을 묶어 하나의 메서드로 작성해 메서드 호출만으로 반복적인 코드를 대체
- 코드 중복제거
- 변경사항이 있을 때 메서드만 수정
##### 프로그램 구조화
- 큰 규모의 프로그램에서 문장들을 작업단위로 나눠 여러 메서드에 담아 프로그램 구조를 단순화한다.

#### 메서드의 선언과 구현
- 선언부(header), 구현부(body)로 이루어져 있다.

```java

접근제어자 반환타입 메서드 이름 (매개변수1, 매개변수2,...) { // 선언부
  //메서드 호출시 수행될 코드, 구현부
}
---
public int addValue(int a, int b){ // 선언부
  int result = a+b// 구현부
  return result; 
}
```
##### 매개변수 선언
- 메서드가 작업을 수행하는데 필요한 값들을 제공받기 위한 것
- 필요한 값의 갯수만큼 변수선언해 각 변수간 구분은 쉼표(,)로함
- 변수 선언과 달리 두 변수의 타입이 같다면 변수의 타입은 한번만 지정해도됨
```java

public int addValue(int a, b){ 
  int result = a+b
  return result; 
}
```
- 매개변수의 수가 많다면 참조형(객체)변수를 선언하면 된다.

##### 메서드 이름
- 변수 명명의 규칙을 적용한다.
- 주로 동사로 메서드 이름을 짓는다.

##### 반환타입
- 메서드 작업수행 결과인 반환값의 타입
- 반환이 없는 경우 void
#### 메서드 구현부
- 선언부 다음에 오는 {}
- 메서드를 호출할 때 수행되는 문장을 넣는다.
#### return
- void가 아닌 경우 {}안에 return 반환값; 이 반드시 포함되어야 한다
- void는 컴파일시 컴파일러가 자동으로 넣어준다.
- 메서드 수행결과를 호출한 메서드로 전달하는데 반환타입과 일치하거나 형변환으로 타입을 맟춰준다.
- 매개변수가 여러개일 수 있어도 반환값은 하나만 허용
#### 지역변수
- 메서드 내 선언된 변수들은 메서드 내 사용

### 메서드 호출 
- 메서드를 정의했어도 호출되지 않으면 아무 일도 일어나지 않음
#### argument, parameter
- 메서드 호출시 괄호 안에 지정해준 값을 '인자', 또는 '인수'라고함
```java
public static void main(String args[]){ 
  ...
  int result = addValue(1,3); // 인자
}

```
- 반환타입이void가 아닌 경우 메서드가 작업을 수행하고 반환값을 대입연산자로 변수에 저장하는게 보통
- 저장안해도됨

#### 메서드 실행 흐름
- 같은 클래스 내 메서드끼리 참조변수를 사용하지 않고도 서로 호출이 가능하지만 static메서드는 같은 클래스 내 인스턴스 메서드 호출할 수 없다.
- 메서드가 호출되면 지금까지 실행되던 코드는 멈춰지고 호출된 메서드의 문장들이 실행된다.
- 매개변수는 메서드가 실행될 때  파라미터로 대입한 값이 대입(복사)된다.
- 만약return 이 있는 함수의 경우 호출한 메서드로 되돌아와 이후 문장들을 실행

### return 문
- 실행중인 메서드 종료하고 호출한 메서드로 되돌아감
- 반환 유무에 상관없이 모든 메서드에 return 이 있어야하며 없는 void메서드는 컴파일시 컴파일러가 `return;`을 삽입한다.

```java

void invokeLoopState(int param) {
    for(int i = 0; i < 10; i++)
    {
      if(param == i)
      System.out.println(i);
    }
    // return; 반환타입이 void이므로 생량가능, 컴파일시 컴파일러가 삽입함
}

int invokeLoopStateReturnInt(int param){
    return param*param; // 반환타입이 void가 아니므로 필수 사항
}

```
#### 반환값
반환값으로 주로 변수가 오기도 하지만 항상그런건 아님

```java

int diff(int x, int y){
  int result = abs(x-y);
  return result;
}
int diff(int x, int y){
  return abs(x-y);
}


int abs(int x){
  if(x>=0){
    return x;
  }else return -x;
}

int abs(int x){
    return x>=0 ? x: -x;
}
```

- if 문을 사용해 리턴값을 조건에따라 다르게 리턴할 수 있지만 
- 삼항연산자를 쓰기도 함
#### 매개변수 유효성 검사

- 메서드 구현주 작성시 가장 먼저 해야함
- 호출되는쪽에서 알아서 적절하게 넘겨주겠지.. 하면 한됨
- Spring에서 매개변수를 검증하는 Validation을 사용하듯 비정상 종료를 막기위해 매개변수를 검증해 적절한 값인지 확인해야함
```java

int abs(int x){
    if(x == null) return 0;

    return x>=0 ? x: -x;

}
```


### JVM의 메모리 구조
- 자바 실행시 JVM 은 시스템으로부터 프로그램을 수행하는데 필요한 메모리할당받아 이 메모리 용도에 따라 여러 영역으로 나누어 관리

1. 메서드 영역
   - 클래스 사용시 JVM은 이 해당 클래스 클래스파일을 읽고 분석해 클래스에대한 정보를 메서드영역에 저장 
   - 클래스변수와 클래스 메서드도 클래스 로딩시 이 영역에 함께 생성 
   -❓ 그럼 컴파일러가 메서드영역에 클래스 변수와 메서드를 할당해주는건가?
    - 프로그램 실행될 때 JVM이 의 클래스 로더가 클래스 파일을 밁고 메타데이터를 메서드 영역에 저장 로드
    - 컴파일 단계에서 컴파일러가 소스파일(.java)을 클래스파일(.class)을 생성(변환)해 바이트코드로 변환함
    - 이때 클래스 파일에 클래스 메타데이터 (클래스 변수와 메서드)가 포함되기때문에 static 키워드를 가진 변수와 메서드에 메모리 할당 
    - 이부분은 자바 어플리케이션 생명주기와 연관이 있음 아래 간략하게 정리 
      - java application lifecycle
      1. 코드 작성 
      2. 컴파일
       - 컴파일러를 사용해 소스파일을 바이트코드로 변환
       - `javac [클래스 이름].java` 
      3. 클래스 로딩
       - 클래스 로더(부트스트랩 , 확장, 애플리케이션 클래스 로더)가 JVM이 필요한 클래스 메모리에 로드 
      4. 링크
       - 로드된 클래스 JVM 명세와 일치하는지 검증
       - 클래스 변수 기본값 초기화해 준비
       - 심볼릭 레퍼런스 실제메모리주소로 변환
      5. 초기화
       - 클래스 초기화블록과 static블록 실행
       - static 변수를 대입된 값으로 초기화
      6. 실행
       - JVM이 main메서드 호출해 샐행
      7. 종료
       -  main메서드가 종료되거나 System.exit()가 호출될 때 종료 
2. 힙
   - 인스턴스 생성공간
   - 객체 생성된 후 인스턴스변수 실행
   - 가비지컬랙션이 관여하는 영역
  
3. 호출스택
   - 호출된 메서드 작업에 필요한 모메리 공간 할당됨
   - 메서드 작업수행중 지역변수와 연산의 중간결과를 이 영역에 저장
   - 메서드가 작업을 마치면 할당됐던 공간 정리됨
   - LIFO 마지막에 호출될 메서드가 먼저 실행 됨


### 기본형 매개변수와 참조형 매개변수
- 메서드 호출시 매갭변수로 지정한 값을 메서드 매개변수에 복사해 넘김
- 매개변수가 기본형이면 기본형의 값이 복사되지만 참조형이면 인스턴스 주소 복사
- 기본형은 단순히 저장된 값만 얻오기때문에 호출전 값과 호출된 메서드에서 다르게 대입했을 때 호출된 메서드가 끝난후 호출스택에서 메서드가 사라졌기때문에 값이 그대로인데
- 참조형은 저장된곳 주소가 있기때문에 값도 변경할 수 있음 해당 예시는 objectOriented/ReferenceParaEx, PrimitiveParamEx 에서 볼 수 있음
- 배열도 참조형객제이기때문에(사용시 new 를 사용해 객체 생성) 주소값으로 값에 접근


### 참조형 반환타입
- 반환타입이 참조형
- 매개변수로 넘겨받은 객제에 저장된 값을 연산해 복사해 반환
```java

 static ReturnData copy(ReturnData data){
        ReturnData tmp = new ReturnData();
        tmp.x =data.x;

        return tmp; // 파라미터로 넘겨받은 객체에 저장된 값을 복사해 반환
  // 리턴 타입과 파라미터가 동일
  }

```
### 재귀호출
- 메서드 내 자기 자신을(메서드를) 다시 호출하는것
- call stack에는 호출때마다 새로운 호출프레인이 생성돼 호출 스택에 추가됨
- 값에 의한 호출을 통해 원래값이 아닌 복사된 값으로 작업해 호출한 메서드와 관계없이 독립적인 작업 수행
- 로직에 재귀오출만 있으면 over flow가 되기 때문에 조건문이 항상 같이 쓰인다.
- 논리적 간결함으로 반복문 대신 재귀호출문이 쓰인다.
- 해당 예시는 `objectOriented/FactorialEx`, `objectOriented/PowerTestEx`시리즈에서 볼 수 있음
  

### 클래스 메서드와 인스턴스 메서드
- 선언할 때 `static`키워드가 있으면 클래스, 없으면 인스턴스 메서드
- 클래스변수는 객체 생성하지 않아도 사용할 수 있음
- 인스턴스 변수를 사용할 수 없음
- 메서드 내 인스턴스 변수를 사용하지 않으면 static을 사용하는것을 고려


### 클래스 맴버와 인스턴스 맴버간의 참조와 호출
- 해당내용은 `objectOriented/MemberCall` 에서 설명을대신하겠음

## 오버로딩
- 해당내용은 `objectOriented/OverLoadingTestEx` 에서 설명을대신하겠음

## 가변인자
- 해당내용은 `objectOriented/VaraggsTestEx` 에서 설명을대신하겠음

## 생성자
- 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드
- 클래스 이름과 생성자 메서드 이름디 동일해야함
- 리턴타입이 없고 void라는 명시가 없어도 됨
- 연산자 `new`가 인스턴스를 생성하는것이지 생성자가 인스턴스를 생성하는것이 아니다.
### 기본생성자
- 생성자를 정의하지 않아도 인스턴스를 생성할 수 있다.
- 컴파일러가 매개변수, 아무내용이 없는 생성자 추가해줌
- 클래스 내 아무런 생성자 선언이 없을경우 추가
### 매개변수가 있는 생성자
- 매서드처럼 선언해 호출시 매개변수를 받아 인스턴스 초기화

### 생성자에서 다른 생성자 호출 this와 this()차이
- 생성자 이름으로 클래스 대신 this 사용
- 다른 생성자를 호출할 때 반드시 생성자 내 첫줄에서 호출가능

```java 
    CarConstructor_(){
        color = "white";
        gearType = "auto";
        door = 3;
    }
   CarConstructor_(){
        // 유기적 연결
        this("white","auto",3);
    }

```
- 두개의 생성자가 똑같은 역할
- 같은 클래스 내 생성자들은 서로 관계가 깊어서로 호출하도록 유기적 연결해주면 더 좋은코드를생성할 수 있음, 수정도 용이
```java
    CarConstructor(String color, String gearType, int door) {
        this.color = color;
        this.gearType = gearType;
        this.door = door;
    }
```
- `this`라는 키워드로 인스턴스 자신에게 접근
- `this`는 인스턴스 멤버만 **this**라는 키워드를 사용할 수 있기때문에 static에서는 사용못함
- `this()`는 같은 클래스 내 다른 생성자를 호출할 때 사용
- ❓그렇다면 하나의 인수만 받는 생성자가 여러개 있을경우 어떻게 구분해?
  - 생성자가 여려개일 경우 오버라이딩과 같은 원리로 호출됨
  - 컴파일러 가 인수의 타입, 갯수로 비교해 호출되도록 도와줌

## 생성자를 이용한 인스턴스 복사
- 두 인스턴스가 같은 상태를 갖는다는 것은 두 인스턴스의 모든 인스턴스변수가 동일한 값을 갖고있다는 것
- 매개변수를 같은 클래스로 받는다면 인스턴스 복사가 된다. 
```java
class CarConstructor_2{
    String color;
    String gearType;
    int door;

    CarConstructor_2(){
        this("white","auto",3);
    }

    CarConstructor_2(CarConstructor_2 c){
        // 인스턴스 복사를 위한 생성자, 매개변수로 받는 인스턴스의 값을 대입
        color = c.color;
        gearType =c.gearType;
        door = c.door;
    }

    CarConstructor_2(String c, String g, int n){
        this.color = c;
        this.gearType = g;
        this.door = n;        
    }
}
```
- 매개변수로 전달된 객체와 원래의 객체는 별도의 객체이기때문에 필드 값만 복사됨
- 인스턴스 생성시 어떤 클래스의 인스턴스를 사용할지, 선택한 클래스의 어떤 생성자로 인스턴스를 생성(복제)할지 생각해야 함

## 변수의 초기화
- 초기화 : 변수선언하고 값을 처음으로 저장하는것
- 경우에 따라 초기화가 필수인로직, 선택인로직이 있음
| 자료형 | 기본값 |
|---|---|
|char|'\u000'|
|boolean|false|
|double|0d|
|byte, short, int|0|
|long|0l|
|float|0f|
|참조형 변수|null|
- 같은 타입의 변수를 두개이상 선언한다면 `,`로 구분해 선언할 수 있음
```
int i=10,j=2;
```
- 초기화는 크게 명시적초기화, 생성자, 초기화블럭 세가지 방법이있다.

### 명시적 초기화
- 변수를 선언과 동시에 초기화
```java
class Car {
  int door = 2;
}

```
- 간단한방법이지만 복잡한 구조의 경우 초기화 블럭 또는 생성자응 이용해 초기화해야함

### 초기화 블럭
- 클래스 변수의 복잡한 초기화에 사용하는  초기화 블럭, 인스턴스 변수 복잡한 초기화에 사용되는 인스턴스 초기화 블럭 두가지 방법이 있음
- 초기화 블럭은 for 또는 if문 내 변수의 최초 값을 대입한다.
```java
int[] intArr = {1,2,3,4};
for(int i : intArr ){
  i=0;
}
class Initial{
  static {/** 클래스 초기화 */ }
  {/* 인스턴스 초기화*/}
}
```
- 클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행, 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할때마다 생성자 보다 먼저 수행
```java

  static{// 클래스 멤버 초기화
        System.out.println("static {}");
    }
    { // 인스턴스 멤버 초기화
        System.out.println("instance {}");
    }
    public InitializationEx1() {
        System.out.println("생성자");
    }

    public void main(){
        System.out.println("InitializationEx1 iz = new InitializationEx1()");
        InitializationEx1 iz = new InitializationEx1();
        System.out.println("InitializationEx1 iz2 = new InitializationEx1()");
        InitializationEx1 iz2 = new InitializationEx1();
        
    }

    /*
     * 
    static {}
    instance {}
    생성자
    InitializationEx1 iz = new InitializationEx1()
    instance {}
    생성자
    InitializationEx1 iz2 = new InitializationEx1()
    instance {}
    생성자
     */

```
- 클래스 멤버 초기화는 런타임시 한번만 초기화 되며 인스턴스 초기화가 생성될때마다 생성자 보다 먼저 실행되는걸 볼 수 있음
- 예제는 해당 경로 InitializationEx1~4에서 확인

## 상속
### 상속 장점
- 기존 클래스 재사용해 새로운 클래스 작성
- 재사용성이 높이고 코드 중복 최소화
- 조상 클래스를 확장(extends) 한다는의미
- `조상 클래스` : 부모 클래스, 상위 클래스, 기반클래스
- `자손 클래스` : 자식 클래스, 하위 클래스, 파생된 클래스

- 생성자와 초기화블럭은 상속되지 않음, 맴버만 상속
- 자손클래스의 멤버 개숫는 조상클래스보다 항상 같거나 많다.
- 
### 클래스간의 관계 - 포함
- 상속 외 클래스 재사용하는 방법 초함(Composition)
- 한 클래스의 맴버변수로 다른 클래스 타입의 참조벼수를 선언
- 한 클래스를 작성하는데 다른 클래스를 멤버변수로 선언해 포함
```java

class Animal{
  public Dog dog;
  public Cat cat;
}

class Dog{

}
class Cat{

}

```
- 자세한 설명은 현재 경로 내 `DrawShapeEx.java, DeckTestEx.java` 참조
### 단일상속
- 자바에서는 단일상속만 허용
- 클래스끼리는 다중상속이 안돼 인터케이스를 만들어 추상팩토리 패턴으로 구현하는것을 추천
- 단일상속으로 클래스간 관계 명확성 확보, 코드신뢰 상승
- 다중상속의 경우 복잡하고 디버깅 어려우며 어떤 클래스의 메서드를 상속했짖 확인이어려움
- 해당 예문은 `TVCR.java`코드 확인
  
### Object 클래스 - 모든 클래스의 조상
- Object는 모든 믈래스 상속계층도 최상위의 조상클래스
- 별도로 상속을 표기 하지 않아도 클래스들은 자동적으로 Object클래스로 부터 상속
- `toString()`, `equals()`와 같은 모든 인스턴스가 가여야할 기본적인 11개의 메서드 정의

## 오버라이딩
- 조상으로부터 상속받은 메서드 새로 정의
- 내용만을 새로 작성
```
- 이름이 같아야 한다.
- 매개변수가 같아야 한다.
- 반환타입이 같아야 한다.

```
- 위 세 조건을 만족해야 한다.
- 선언부 일치, 접근제어자와 예외는 제한된 조건 하나에서만 다르게 변경
1. 접근제어자는 조상클래스 보다 좁은 볌위로 변경할 수 엊ㅅ다.
2. 조상클래스의 메서드 보다 많은 수의 예외를 선언할 수 없아.
```java
class Parent {
  void parentMethod() throw IOException, SQLException{
    ...
  }
}
class Child extends Parent {
   void parentMethod() throw Exception{
    ...
  }
}
- 조상클래스보다 예외를 적게 선언한것 처럼 보이지만 모든 예외의 최고 조상이므로 가장 많은 개수의 예외를 던질 수 있도록 선언


```
3. 인스턴스 메서드를 static 메서드 또는 그 반대로 변경할 수 없다.
### 오버로딩 VS 오버라이딩
- 오버로딩 : 기존에 없는 새 매서드 추가
- 오버 라이딩 : 조상으로부터 상속받은 메서드 내용 변경
### super
- 자손클래스에서 조상클래스로부터 상속받은 맴버 참조하는 참조변수
- 맴버변수와 지역변수명이 같을 때 this를 붙여 구별, 상속받은 멤버와  자신의 멤버와 이름같을 때 super붙여구별
- 조상으로부터 상속받은 변수도 자식의 멤버이브로 super 대신this 사용할 수 있지만 조상클래스와 자손클래스 멤버구분을위해 사용
- static 메서드는 인스턴스 메서드와 관련없음, this, super 모두
- super는 참조가 아니기 때문에 super.super로 사용할 수 없음
### super()
- this()와 마찬가지로 super()역시 생성자
- this()는 같은 클래스 다른 생성자를 호출하지만 super()는 조상클래스 생성자 호출
- Object클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 부모 생성자호출

## 패키지와 임폴트
### package
- 클래스 묶음, 디렉토리
- 하나의 소스파일에는 하나의 패키지선언만을 허용
- .을 구분자로 계층구조러 작성할 수 있음

```
mydir > javac -d . PackaeTest.java # 소스파일에 지정된 패키지 경로로 해당 파일을 찾아 클래스파일생생성함

#클래스 패스 추가 여러개 지정할 땐 ; 로 구분
mydir >SET CLASSPATH=.;MyPath/Mydir;MyPath/Mydir2
```
### import
- 소스코드 작성시 import문으로 사용하고자하는 클래스 패키지 명시
- ``` import java.util.* ``` 이렇게 *를 표시하면 하위의 경로 클래스들도 포함하는것은 아님
### static import
- static 멤버 호출할 때 클래스 명 생략
```java

import static java.lang.Integer.* // Integer 클래스 내 모든 클래스 멤버들
import static java.lang.Math.random.* // 괄호 안붙음


```
- 하지만 명확하지 않기때문에 부득이한 때가 아니라면 사용 지양

## 다형성
- 조상클래스 타입의 참조변수로 자손클래스의 인스턴스 참조할 수 있도록 함, 이때 조상클래스와 자식 클래스킄 상속관계
- 자식의 참조변수로 조상 의 인스턴스 멤버로 상요할 수 없는것은 조상클래스에서 자식 참조 변수의 존재하지 않는 맴버를사용할 수 있어 허용하지 않음.
- 모든 참조변수는 null또는 4byte의 주소값이 저장됨
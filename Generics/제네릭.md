# Generics 제네릭

- java API에서 제네릭을 모르면 문서를 볼 수 없을정도로 중요함
- 컴파일시 타입을 체크해주는 기능.
- 객체 타입 안정성을 높이고 형변환의 번거로움을 줄여줌
- `타입의 안정성을 높인다` : 의도하지않은 타임의 객체가 저장되는 것을 막고 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환 되어 발생할 수 있는 오류를 줄여줌
- 컬랙션프레임워크는 다양한 종류의 객체를 담을 수 있지만 보통 한종류의 객체를 담는데 꺼낼때마다 형변환을 하게되면 불편하고 비용이 발생한다. 원치않은 객체가 포함된다는것을 막을 수 없는데 이를 보완해 주는게 제네릭이다

```
타입의 안정성제공
타입체크와 형변환 생략할 수 있으므로 코드가 간결해진다.
```

### 제네릭 클래스 선언

- 클래스와 메서드에 제네릭을 선언할 수 있다. 

```java

class Box{
    Object item;
    void setItem(Object item ){ this.item = item;}
    Object getItem(){ return item;}

}

```

- 현재 크랠스의제네릭을 변경하면 클래스 옆에 `<T>`를 붙인다.
- 그리고  Object를 모두 `T`로 바꾼다.

```java
class Box<T>{
    T item;
    void setItem(Object item ){ this.item = item;}
    T getItem(){ return item;}

}

```


- Box<T>에서 T를 타입변수라고 한다. 이 타입의Type에서 'T'를 따온 것
- ArrayList<E> 에서 E는 Element에서 따온것
- 타입변수가 여러개일 경우 Map<Key, Value>처럼 ,(콤마)로 구분한다.
- 무조건T를 쓰기보다 이처럼 구분할 수 있는 <K,V>형태로 사용한다.
- 이들은 기호 종류만 다를 뿐 임의의 참조형 타입을 의미한다.
- 기존의 다양한타입을 다루는 메서드의 매개변수나 리턴타입을 주로 Object의 참조변수를 사용했다. 그로인해 형변환이 불가피햇지만 이를 보완하기위해 타입을 지정하면 된다.

```java

Box<String> b = new Box<String>();
b.setItem(new Object());
b.setItem("김현경");
String item = b.getItem();

```

위 코드에서 타입을 String 으로 지정했으므로 제네릭 클래스의 Box<T>는 다음과 같다.

```java
class Box{
    String item;
    void setItem(Object item ){ this.item = item;}
    String getItem(){ return item;}

}

```
- 물론 제네릭 도입 전 방식으로 객체를 생성하는것이 가능해 호환히 된다. 
- 다만 제네릭을 지정하지않아 안전하지않다는 경고가 뜬다.


```java
// 제네릭 도입 전
Box b = new Box();
b.setItem("ABC"); //unchecked or unsafe operation
b.setItem(new Object());


// 제네릭 도입 후
Box<String> b = new Box<String>();
b.setItem("ABC");
b.setItem(new Object());



```

### 제네릭 용어
 
- 햇갈리기 쉬워서 아래 코드박스르 참고하길..

```java

class Box<T> {} 

// Box : 원시타입(객체는 원시타입)
// Box<T> : 제네릭스. T의 Box 또는 T Box라고 읽는다.
// T: 타입의 변수 또는 타입 매개변수(T라는 타입의 문자)


Box<String> b = new Box<String>();

//String 대입된 타입, 매개변수화된 타입
//Box<String> b = new Box<String>(); : 호출된 제네릭 타입

```

- Box<String>과 Box<Integer>는 서로 다른 타입을 대입해 호출했다.
- 더로 다른 타입을 호출했을 뿐 별도의 개별적인 클래스가 아니다.
- 컴파일 후 Box<String>과 Box<Integer>는 이들의 원시타입인 Box로 바뀐다. => 제네릭<String>과 <Integer>는 사라진다.(이 부분은 제네릭타입의 제거 에서 상세히 다룬다)

### 제네릭스의 제한
- 제네릭 Box의 객체를 생성할 때 객체별로 다른 타입을 지정할 수 있다. 적절하다.인스턴스별로 다르게 동작하기 위해 만든기능이기 때문에


```java

Box<Apple> appleBox = new Box<Apple>();
Box<Grape> grapeBox = new Box<Grape>();

```

- `static타입의 변수는 제네릭을 사용할 수 없다.` 모든객체에 동일하게 동작해야하기때문에 `인스턴스로 간주되는 T는 static맴버변수는 인스턴스를 참조할 수 없기때문이다.`

```
class Box<T>{
    static T item ; //에러
    static int compare(T t1, T t2){...} // 에러
}


```
- static멤버는 타입변수에 지정된 타입, 즉 대입된 타입의 종류에 관계없이 동일해야 하기때문이다.
- 위 코드박스의 T[] 맴버변수처럼제네릭 터입의 배열을 생성하는것도 허용이 안된다.
- T[]의 참조변수 선언은 가능하지만 new T[100] 처럼 배열을 생성하는것은 안된다.

```java 



class Box<T>{
    T[] itemArray;
    T[] toArray(){
        T[] tmpArray = new T[itemArray.length];
        ...
        return tmpArray;
    }
}

```

- 제네릭 배열을 생성못하는것은 new연산자때문이다.
- new 연산자는 컴파일 시점에서 타입T가 무엇인지 알아야 하는데 Box<T>클래스를 컴파일하는 시점에서는 T가 어떤 타입인지알 수 없다.
- Instancof연산자도 마찬가지.
- 꼭 제네릭 배열을 생성할 때 new 대신 Reflextion API의 newInstance()과 같이 동적으로 객체를 생성하는 메서드로 배열을 생성하거나 Object배열을 생성해 copy한 다음 T[]로 변환하는 방법등을 사용한다.
- Collections.toArray(T[] t)의 소스를 참고해야함.

```java
// Collections 의 toArray()는 Object[]을 리턴한다.
public Object[] toArray()                  {return c.toArray();}

// 참고로 변수 c는 Collection<? extends E>의 맴버변수 c이다.
    @SuppressWarnings("serial") // Conditionally serializable
    final Collection<? extends E> c;

```
- 즉 컬렉션의 Object[]로 리턴한다는 것이다.


## 제네릭 클래스의 객체 ㅐㅇ성과 사용

- Box<T>클래스의 객체레는 한가지 종류, 즉T타입의 객체만 저장할 수 있다.

```java
class Box<T>{
    ArrayList<T> list = new ArrayList<T>();

    void add(T item ){ list.add(item);}
    T get(int i){return list.get(i)}
    String getItem(){ return item;}
    ArrayList<T> getList() {return list;}
    int size(){return list.size();}
    public String toString() { return list.toSTring();}
}

```

- 위와 같이 Box<T>라고 정의되어있을 때 T타입만 저장할 수 있다.
- 참조변수와 생성자에 대입된 타입(파라미터화된 타입, 매개번수화된 타입)이 일치해야한다. 안그러면 에러 발생

```java

Box<Apple> b = new Box<Apple>();
Box<Grape> b = new Box<Apple>();// Error


class Apple extends Fruit{
    ...
}

Box<Fruit> b = new Box<Apple>();//에러!
// Apple는 Fruit의 자손이지만 타입이 다르다는 에러 발생 
// ---------------------
class FruitBox extends Box{
    ...
}

Box<Apple> b = new FruitBox<Apple>(); // OK, 다형

```


- JDK 1.7부터 추정이 가능한 경우 타입을 생략할 수 있게 되었다.
- 참조 변수 타입으로만 봐서도 Box가 Apple타입의 객체만 저장한다는 것을 알 수 있다.
- 생성자에 반복해서 타입을 지정해 주지 않아도 된다.
- add(T item )으로 객체를 추가할 때 대입된 다입과 다른 타입의 객체는 추가할 수 없다.


```java

Box<Apple> b = new Box<Apple>();
b.add(new Apple());
b.add(new Grape()); //에러

```

하지만 아래의 코드박스처럼 제네틱 타입이 상속관계에 있다면 다르다.

```java

class Apple extends Fruit{
    ...
}

Box<Fruit> b = new Box<Fruit>();

b.add(new Apple());
b.add(new Fruit());


```

